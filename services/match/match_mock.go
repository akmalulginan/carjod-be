// Code generated by MockGen. DO NOT EDIT.
// Source: domain/match.go

// Package match is a generated GoMock package.
package match

import (
	context "context"
	reflect "reflect"

	domain "github.com/akmalulginan/carjod-be/domain"
	gomock "github.com/golang/mock/gomock"
)

// MockMatchUsecase is a mock of MatchUsecase interface.
type MockMatchUsecase struct {
	ctrl     *gomock.Controller
	recorder *MockMatchUsecaseMockRecorder
}

// MockMatchUsecaseMockRecorder is the mock recorder for MockMatchUsecase.
type MockMatchUsecaseMockRecorder struct {
	mock *MockMatchUsecase
}

// NewMockMatchUsecase creates a new mock instance.
func NewMockMatchUsecase(ctrl *gomock.Controller) *MockMatchUsecase {
	mock := &MockMatchUsecase{ctrl: ctrl}
	mock.recorder = &MockMatchUsecaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMatchUsecase) EXPECT() *MockMatchUsecaseMockRecorder {
	return m.recorder
}

// Action mocks base method.
func (m *MockMatchUsecase) Action(ctx context.Context, data *domain.Match) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Action", ctx, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// Action indicates an expected call of Action.
func (mr *MockMatchUsecaseMockRecorder) Action(ctx, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Action", reflect.TypeOf((*MockMatchUsecase)(nil).Action), ctx, data)
}

// GetCandidate mocks base method.
func (m *MockMatchUsecase) GetCandidate(ctx context.Context, userId string) (domain.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCandidate", ctx, userId)
	ret0, _ := ret[0].(domain.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCandidate indicates an expected call of GetCandidate.
func (mr *MockMatchUsecaseMockRecorder) GetCandidate(ctx, userId interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCandidate", reflect.TypeOf((*MockMatchUsecase)(nil).GetCandidate), ctx, userId)
}

// GetMatches mocks base method.
func (m *MockMatchUsecase) GetMatches(ctx context.Context, userId string) ([]domain.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMatches", ctx, userId)
	ret0, _ := ret[0].([]domain.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMatches indicates an expected call of GetMatches.
func (mr *MockMatchUsecaseMockRecorder) GetMatches(ctx, userId interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMatches", reflect.TypeOf((*MockMatchUsecase)(nil).GetMatches), ctx, userId)
}

// MockMatchRepository is a mock of MatchRepository interface.
type MockMatchRepository struct {
	ctrl     *gomock.Controller
	recorder *MockMatchRepositoryMockRecorder
}

// MockMatchRepositoryMockRecorder is the mock recorder for MockMatchRepository.
type MockMatchRepositoryMockRecorder struct {
	mock *MockMatchRepository
}

// NewMockMatchRepository creates a new mock instance.
func NewMockMatchRepository(ctrl *gomock.Controller) *MockMatchRepository {
	mock := &MockMatchRepository{ctrl: ctrl}
	mock.recorder = &MockMatchRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMatchRepository) EXPECT() *MockMatchRepositoryMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *MockMatchRepository) Create(ctx context.Context, data *domain.Match) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockMatchRepositoryMockRecorder) Create(ctx, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockMatchRepository)(nil).Create), ctx, data)
}

// FindByUserId mocks base method.
func (m *MockMatchRepository) FindByUserId(ctx context.Context, userId string, isToday bool) ([]domain.Match, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByUserId", ctx, userId, isToday)
	ret0, _ := ret[0].([]domain.Match)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByUserId indicates an expected call of FindByUserId.
func (mr *MockMatchRepositoryMockRecorder) FindByUserId(ctx, userId, isToday interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByUserId", reflect.TypeOf((*MockMatchRepository)(nil).FindByUserId), ctx, userId, isToday)
}

// FindLiked mocks base method.
func (m *MockMatchRepository) FindLiked(ctx context.Context, userId, targetId string) (domain.Match, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindLiked", ctx, userId, targetId)
	ret0, _ := ret[0].(domain.Match)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindLiked indicates an expected call of FindLiked.
func (mr *MockMatchRepositoryMockRecorder) FindLiked(ctx, userId, targetId interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindLiked", reflect.TypeOf((*MockMatchRepository)(nil).FindLiked), ctx, userId, targetId)
}

// Update mocks base method.
func (m *MockMatchRepository) Update(ctx context.Context, data *domain.Match) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *MockMatchRepositoryMockRecorder) Update(ctx, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockMatchRepository)(nil).Update), ctx, data)
}
